/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package myjnet;







/**
 *
 * @author nri
 */
import java.util.ArrayList;  
import java.util.Date;  
import java.util.List;  
  
import org.jnetpcap.Pcap;  
import org.jnetpcap.PcapBpfProgram;
import org.jnetpcap.PcapDumper;
import org.jnetpcap.PcapIf;  
import org.jnetpcap.packet.PcapPacket;  
import org.jnetpcap.packet.PcapPacketHandler;  
import org.jnetpcap.protocol.tcpip.Tcp;
import org.jnetpcap.protocol.network.Ip4;


  
/** 
 * Here is the output generated by this example : 
 *  
 *  Network devices found: 
 *  #0: \Device\NPF_{BC81C4FC-242F-4F1C-9DAD-EA9523CC992D} [Intel(R) PRO/100 VE]  
 *  #1: \Device\NPF_{E048DA7F-D007-4EEF-909D-4238F6344971} [VMware Virtual Ethernet Adapter] 
 *  #2: \Device\NPF_{5B62B373-3EC1-460D-8C71-54AA0BF761C7} [VMware Virtual Ethernet Adapter] 
 *  #3: \Device\NPF_GenericDialupAdapter [Adapter for generic dialup and VPN capture] 
 *  
 *  Choosing 'Intel(R) PRO/100 VE) ' on your behalf: 
 *  Received packet at Tue Nov 03 18:52:42 EST 2009 caplen=1362 len=1362 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=82   len=82   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=145  len=145  jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=62   len=62   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=164  len=164  jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=62   len=62   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=54   len=54   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=1073 len=1073 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=1514 len=1514 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=279  len=279  jNetPcap rocks! 
 */  
public class MyJnet {  
  
    /** 
     * Main startup method 
     *  
     * @param args 
     *          ignored 
     */  
    public static void main(String[] args) {  
        List<PcapIf> alldevs = new ArrayList<PcapIf>(); // Will be filled with NICs  
        StringBuilder errbuf = new StringBuilder(); // For any error msgs  
  
        /*************************************************************************** 
         * First get a list of devices on this system 
         **************************************************************************/  
        int r = Pcap.findAllDevs(alldevs, errbuf);  
        if (r == Pcap.NOT_OK || alldevs.isEmpty()) {  
            System.err.printf("Can't read list of devices, error is %s", errbuf  
                .toString());  
            return;  
        }  
  
        
         System.out.println("Network devices found: ");  
  
        
        // Print out the devices
        for (PcapIf dev : alldevs) {
            System.out.println("Dev: " + dev.toString());
        }
        
        // Print out device description
        int i = 0;  
        for (PcapIf device : alldevs) {  
            String description =  
                (device.getDescription() != null) ? device.getDescription()  
                    : "No description available";  
            System.out.printf("#%d: %s [%s]\n", i++, device.getName(), description);  
        }  

        System.out.println("\nMyDevice should be here: " + alldevs.get(2));
        
        // set main device        
        PcapIf device = alldevs.get(1); // Look this up. Here 2 is my wifi machine.  1 = ethernet      
        System.out.println("getFlags: " + device.getFlags());
        
        System.out  
            .printf("\nChoosing '%s' on your behalf:\n",  
                (device.getDescription() != null) ? device.getDescription()  
                    : device.getName());  
  
        /*************************************************************************** 
         * Second we open up the selected device 
         **************************************************************************/  
        int snaplen = 512;//64*1024;           // Capture all packets, no trucation  
        
        int flags = Pcap.MODE_PROMISCUOUS; // capture all packets  
        int timeout = 1 * 300;           // 10 seconds in millis  
        Pcap pcap =  
            Pcap.openLive(device.getName(), snaplen, flags, timeout, errbuf);  
        
        if (pcap == null) {  
            System.err.printf("Error while opening device for capture: "  
                + errbuf.toString());  
            return;  
        }  
        
        // Dumper file
        String ofile = "mycap.cap";  
        PcapDumper dumper = pcap.dumpOpen(ofile); // output file


        // We set a filter here. If filter is not set, snaplen will not work!
        // Regardless, it's goo to have a filter.
        PcapBpfProgram bpf = new PcapBpfProgram();        
        int optim = 0;
        int netm = 0xFFFFFF00; // Not sure if this has an effect!?
        
        
        //String compStr = "host 10.4.189.152 and (10.4.189.1 or 10.4.160.10 or 10.4.160.11)"; 
         //String compStr = "host 10.4.189.152 and 10.4.189.1"; 
        // String compStr = "host 10.4.189.1"; 
        //String compStr = "host 10.4.189.152 and 80.239.174.123";
        //String compStr = "host 10.4.189.152";
        //String compStr = "host 192.168.43.1 and 192.168.43.190";        
        //String compStr = "host 192.168.43.190 and 192.168.43.213";
        //String compStr = "host 192.168.43.229";       
        //String compStr = "host 192.168.43.1";
        String compStr = "";
        // Compile the filter
        int retFilterCompiler = pcap.compile(bpf, compStr, optim, netm);
        
        int retSetFilter = pcap.setFilter(bpf);
        if (retSetFilter==-1) {
            // double check to see that compiler also gave an error
            if (retFilterCompiler==Pcap.OK){
                System.out.println("Strange... Compiler error missing!");
            }
            System.out.println("SetFilter FAILED");
            System.err.println(pcap.getErr());
            
            // We dont want to continue. Return
            return;
        }
        else {
            // All good
            System.out.println("\nSetFilter SUCCEED -> " + compStr + "\n");
        }
        
        
        
        
        /*************************************************************************** 
         * Third we create a packet handler which will receive packets from the 
         * libpcap loop. 
         **************************************************************************/  
        PcapPacketHandler<String> jpacketHandler = new PcapPacketHandler<String>() {  
            
            @Override
            public void nextPacket(PcapPacket packet, String user) {  
                
                System.out.printf("Received packet at %s caplen=%-4d len=%-4d %s\n",  
                    new Date(packet.getCaptureHeader().timestampInMillis()),   
                    packet.getCaptureHeader().caplen(),  // Length actually captured  
                    packet.getCaptureHeader().wirelen(), // Original length   
                    user                                 // User supplied object  
                    );
                
                // Lets extract som IP addresses and protocols.
                Tcp tcp = new Tcp();
                Ip4 ip = new Ip4();
                byte[] sIP = new byte[4];
                byte[] dIP = new byte[4];
                String sourceIP;
                String destIP;
                if(packet.hasHeader(ip)&&packet.hasHeader(tcp)){
                    sIP = packet.getHeader(ip).source();
                    sourceIP = org.jnetpcap.packet.format.FormatUtils.ip(sIP);
                    dIP = packet.getHeader(ip).destination();
                    destIP = org.jnetpcap.packet.format.FormatUtils.ip(dIP);
                    System.out.println("*"+sourceIP+"*"+destIP);
                    System.out.println("Source IP"+ sourceIP);
                    System.out.println("Destination IP"+ destIP);
                   
                    
                    
                    if (tcp.source()==80){
                        System.out.println("\n\nHTTP protocol 80\n\n");
                    }
                    else if (tcp.source()==23) {                    
                        System.out.println("\n\nTelnet protocol 23\n\n");                        
                    }
                    else if (tcp.source()==443) {
                        System.out.println("\n\nHTTPS protocol 443\n\n");
                    }
                    else {
                        System.out.println("\n\n Protocol ? \n" + tcp.source());                        
                    }
                    

                } 
                else {
                    System.out.println("No header Found: ");
                }
               
               
                // System.out.println("\n\nCapture header \n" + packet.getCaptureHeader().toDebugString()); 
                System.out.println("To String:\n" + packet.toString());
                //System.out.println(" ");
                //System.out.println("To HexDump:\n" + packet.toHexdump());
                             
         
          
                
                
                
                
            }  
        };  
  
        /*************************************************************************** 
         * Fourth we enter the loop and tell it to capture 10 packets. The loop 
         * method does a mapping of pcap.datalink() DLT value to JProtocol ID, which 
         * is needed by JScanner. The scanner scans the packet buffer and decodes 
         * the headers. The mapping is done automatically, although a variation on 
         * the loop method exists that allows the programmer to sepecify exactly 
         * which protocol ID to use as the data link type for this pcap interface. 
         **************************************************************************/  
        
        // I used 0 before.. but loop_infinite seems to be working good. I'll keep it for now.
        // pcap.loop(0, jpacketHandler, "Nima rocks!");  
        //pcap.loop(Pcap.LOOP_INFINITE, jpacketHandler, "Nima rocks!");  
        pcap.loop(20, jpacketHandler, "Nima rocks!");  
        
        
        
        
        /*************************************************************************** 
         * Last thing to do is close the pcap handle 
         **************************************************************************/  
        pcap.close();  
        
        
    } 
    
}  
