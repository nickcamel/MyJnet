/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package myjnet;







/**
 *
 * @author nri
 */
import java.util.ArrayList;  
import java.util.Date;  
import java.util.List;  
import java.io.FileInputStream;



import org.jnetpcap.Pcap;  
import org.jnetpcap.PcapBpfProgram;
import org.jnetpcap.PcapDumper;
import org.jnetpcap.PcapIf;  
import org.jnetpcap.packet.PcapPacket;  
import org.jnetpcap.packet.PcapPacketHandler;  
import org.jnetpcap.protocol.tcpip.Tcp;
import org.jnetpcap.protocol.network.Ip4;


/* for ratiotap */
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;


import fr.bmartel.pcapdecoder.PcapDecoder;
import fr.bmartel.pcapdecoder.structure.types.inter.IEnhancedPacketBLock;
import fr.bmartel.pcapdecoder.utils.DecoderStatus;
import fr.bmartel.protocol.radiotap.RadioTap;
import fr.bmartel.protocol.radiotap.inter.IRadioTapFrame;
import fr.bmartel.utils.RadioTapException;

import fr.bmartel.radiotapdecoder.main.DecodeMain;
import fr.bmartel.radiotapdecoder.main.DisplayPacket;
import java.io.FileOutputStream;
import java.nio.charset.Charset;
import static java.nio.file.Files.size;
import java.util.Arrays;
import org.jnetpcap.JBufferHandler;
import org.jnetpcap.PcapHeader;
import org.jnetpcap.nio.JBuffer;
import utilities.PcapDecoderMe;

  
/** 
 * Here is the output generated by this example : 
 *  
 *  Network devices found: 
 *  #0: \Device\NPF_{BC81C4FC-242F-4F1C-9DAD-EA9523CC992D} [Intel(R) PRO/100 VE]  
 *  #1: \Device\NPF_{E048DA7F-D007-4EEF-909D-4238F6344971} [VMware Virtual Ethernet Adapter] 
 *  #2: \Device\NPF_{5B62B373-3EC1-460D-8C71-54AA0BF761C7} [VMware Virtual Ethernet Adapter] 
 *  #3: \Device\NPF_GenericDialupAdapter [Adapter for generic dialup and VPN capture] 
 *  
 *  Choosing 'Intel(R) PRO/100 VE) ' on your behalf: 
 *  Received packet at Tue Nov 03 18:52:42 EST 2009 caplen=1362 len=1362 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=82   len=82   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=145  len=145  jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=62   len=62   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=164  len=164  jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=62   len=62   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=54   len=54   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=1073 len=1073 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=1514 len=1514 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=279  len=279  jNetPcap rocks! 
 */  
public class MyRadioTapFile {  
  
    /** 
     * Main startup method 
     *  
     * @param args 
     *          ignored 
     */  
    public static void main(String[] args) {  
        List<PcapIf> alldevs = new ArrayList<PcapIf>(); // Will be filled with NICs  
        StringBuilder errbuf = new StringBuilder(); // For any error msgs  
  
        /*************************************************************************** 
         * First get a list of devices on this system 
         **************************************************************************/  
       
        //String fname = "C:\\users\\nri\\Downloads\\mesh.pcap";
        String fname = "C:\\users\\nri\\Downloads\\beacon.pcap";
        
        Pcap pcap = Pcap.openOffline(fname, errbuf);
            
 
                
        

        try {

            decode_me(fname);

        }
        catch (Exception me){
            System.out.println(me);

        }
        
        /*************************************************************************** 
         * Last thing to do is close the pcap handle 
         **************************************************************************/  
        pcap.close();
        
        
    } 
    

    
    
    
    public static void decode_me(String myfile) {
        
            
        byte[] dataFromFile = new byte[]{};
        

        dataFromFile = readFile(myfile);
        
        
    }
    
    
    public static byte[] readFile(String path) {
        
        // Init
        FileInputStream fis = null;        
        byte[] data = null;
        int max_byte_read = 160;
        try {
            // Get the file
            fis = new FileInputStream(path);
            
            System.out.println("Available bytes : " + fis.available());
            
            data = new byte[fis.available()-40];
            
            
            
            
            
            // throw away first 40 bytes (magic number etc etc...)
            System.out.println("Throwing away Frame header!");
            for (int k=0;k<40;k++){
                //fis.read();
                System.out.printf("%s ", Integer.toHexString((fis.read()|0x100)).substring(1));
                if ((k+1)%4==0 && k>0){
                    System.out.println("");
                }
            }
            
            fis.read(data, 0, fis.available()-40);          
            
            /**
             * Kepping this section just for printing (dev)
             */
            int i = 0;
            for (byte b : data) {
                    
                if (i%16==0){
                    
                    System.out.printf("%s: ", Integer.toHexString(i|0x100).substring(1));
                }
                
                if (b>=0) {
                    System.out.printf("%s ", Integer.toHexString(b|0x100).substring(1));
                    //System.out.printf("Byte : %s  Hex : %s\n", b, Integer.toHexString(b));
                }
                else {
                    System.out.printf("%s ", Integer.toHexString(256+b));
                    //System.out.printf("Byte : %s  Hex : %s\n", b, Integer.toHexString(256+b));
                }
                
                i++;
                if (i%16==0){
                    System.out.println("");
                }
                
                if (i>=max_byte_read){
                    System.out.println("");
                    break;
                }
            }
            
             /**
            * 
            */
            int[] data_int = new int[max_byte_read];
            for (int k = 0; k<max_byte_read; k++) {
               data_int[k] = data[k]&0xFF;
            }

            byte[] frame_control = new byte[2];
            byte[] duration = new byte[2];
            byte[] dest_ip = new byte[6];
            byte[] src_ip = new byte[6];
            byte[] bss_id = new byte[6];
            byte[] seq_ctrl = new byte[2];
            byte[] time_stamp = new byte[8];
            byte[] beacon_interval = new byte[2];
            byte[] capability_info = new byte[2];
            byte[] tag_nr = new byte[1];
            byte[] tag_len = new byte[1];
           
            if (data_int[0]==0x80) {
                // It's a beacon
                System.out.printf("It's a beacon!\n");
                frame_control = Arrays.copyOfRange(data, 0, 2);
                duration = Arrays.copyOfRange(data, 2, 4);
                dest_ip = Arrays.copyOfRange(data, 4, 10);
                src_ip = Arrays.copyOfRange(data, 10, 16);
                bss_id = Arrays.copyOfRange(data, 16, 22);
                seq_ctrl = Arrays.copyOfRange(data, 22, 24);
                time_stamp = Arrays.copyOfRange(data, 24, 32);
                beacon_interval = Arrays.copyOfRange(data, 32, 34);
                capability_info = Arrays.copyOfRange(data, 34, 36);
                tag_nr = Arrays.copyOfRange(data, 36, 37);
                tag_len = Arrays.copyOfRange(data, 37, 38);
                
                int ss_id_len = tag_len[0];
                
                byte[] ss_id = new byte[ss_id_len];
                
                ss_id = Arrays.copyOfRange(data, 38, 38+ss_id_len);
                    
                System.out.printf("SSID: ");
                for (byte b : ss_id) {
                    int c = b&0xFF;
                    System.out.printf("%s", (char) c);    
                }
                System.out.println("");
            }
            else {
                System.out.println("Not a beacon unfortunately");
            }
          
        } catch (IOException e) {
                System.err.print("Error file path is incorrect");
        }
 
        
       
        
        
            
        return data;
    }
}  
