/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package myjnet;







/**
 *
 * @author nri
 */
import java.util.ArrayList;  
import java.util.Date;  
import java.util.List;  
  
import org.jnetpcap.Pcap;  
import org.jnetpcap.PcapBpfProgram;
import org.jnetpcap.PcapDumper;
import org.jnetpcap.PcapIf;  
import org.jnetpcap.packet.PcapPacket;  
import org.jnetpcap.packet.PcapPacketHandler;  
import org.jnetpcap.protocol.tcpip.Tcp;
import org.jnetpcap.protocol.network.Ip4;


/* for ratiotap */
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;


import fr.bmartel.pcapdecoder.PcapDecoder;
import fr.bmartel.pcapdecoder.structure.types.inter.IEnhancedPacketBLock;
import fr.bmartel.pcapdecoder.utils.DecoderStatus;
import fr.bmartel.protocol.radiotap.RadioTap;
import fr.bmartel.protocol.radiotap.inter.IRadioTapFrame;
import fr.bmartel.utils.RadioTapException;

import fr.bmartel.radiotapdecoder.main.DecodeMain;
import fr.bmartel.radiotapdecoder.main.DisplayPacket;
import java.io.FileOutputStream;
import java.nio.charset.Charset;
import org.jnetpcap.JBufferHandler;
import org.jnetpcap.PcapHeader;
import org.jnetpcap.nio.JBuffer;
import utilities.PcapDecoderMe;

  
/** 
 * Here is the output generated by this example : 
 *  
 *  Network devices found: 
 *  #0: \Device\NPF_{BC81C4FC-242F-4F1C-9DAD-EA9523CC992D} [Intel(R) PRO/100 VE]  
 *  #1: \Device\NPF_{E048DA7F-D007-4EEF-909D-4238F6344971} [VMware Virtual Ethernet Adapter] 
 *  #2: \Device\NPF_{5B62B373-3EC1-460D-8C71-54AA0BF761C7} [VMware Virtual Ethernet Adapter] 
 *  #3: \Device\NPF_GenericDialupAdapter [Adapter for generic dialup and VPN capture] 
 *  
 *  Choosing 'Intel(R) PRO/100 VE) ' on your behalf: 
 *  Received packet at Tue Nov 03 18:52:42 EST 2009 caplen=1362 len=1362 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=82   len=82   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=145  len=145  jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=62   len=62   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=164  len=164  jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=62   len=62   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=54   len=54   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=1073 len=1073 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=1514 len=1514 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=279  len=279  jNetPcap rocks! 
 */  
public class MyRadioTap {  
  
    /** 
     * Main startup method 
     *  
     * @param args 
     *          ignored 
     */  
    public static void main(String[] args) {  
        List<PcapIf> alldevs = new ArrayList<PcapIf>(); // Will be filled with NICs  
        StringBuilder errbuf = new StringBuilder(); // For any error msgs  
  
        /*************************************************************************** 
         * First get a list of devices on this system 
         **************************************************************************/  
        int r = Pcap.findAllDevs(alldevs, errbuf);  
        if (r == Pcap.NOT_OK || alldevs.isEmpty()) {  
            System.err.printf("Can't read list of devices, error is %s", errbuf  
                .toString());  
            return;  
        }  
  
        
         System.out.println("Network devices found: ");  
  
        
        // Print out the devices
        for (PcapIf dev : alldevs) {
            System.out.println("Dev: " + dev);
        }
        
        // Print out device description
        int i = 0;  
        for (PcapIf device : alldevs) {  
            String description =  
                (device.getDescription() != null) ? device.getDescription()  
                    : "No description available";  
            System.out.printf("#%d: %s [%s]\n", i++, device.getName(), description);  
        }  

        System.out.println("\nMyDevice should be here: " + alldevs.get(2));
        
        // set main device        
        PcapIf device = alldevs.get(1); // Look this up. Here 2 is my machine.        
        System.out.println("getFlags: " + device.getFlags());
        
        System.out  
            .printf("\nChoosing '%s' on your behalf:\n",  
                (device.getDescription() != null) ? device.getDescription()  
                    : device.getName());  
  
        /*************************************************************************** 
         * Second we open up the selected device 
         **************************************************************************/  
        int snaplen = 512;//64*1024;           // Capture all packets, no trucation  
        
        int flags = Pcap.MODE_PROMISCUOUS; // capture all packets  
        int timeout = 1 * 300;           // 10 seconds in millis  
        Pcap pcap = 
            Pcap.openLive(device.getName(), snaplen, flags, timeout, errbuf);  
        
        if (pcap == null) {  
            System.err.printf("Error while opening device for capture: "  
                + errbuf.toString());  
            return;  
        }  
        
        // We set a filter here. If filter is not set, snaplen will not work!
        // Regardless, it's good to have a filter.
        PcapBpfProgram bpf = new PcapBpfProgram();        
        int optim = 0;
        int netm = 0xFFFFFF00; // Not sure if this has an effect!?
        
        
        //String compStr = "host 10.4.189.152 and (10.4.189.1 or 10.4.160.10 or 10.4.160.11)"; 
         //String compStr = "host 10.4.189.152 and 10.4.189.1"; 
        //String compStr = "host 10.4.189.152 and 80.239.174.123";
        String compStr = "host 10.4.189.162";
        //String compStr = "host 192.168.43.1 and 192.168.43.190";        
        //String compStr = "host 192.168.43.190 and 192.168.43.213";
        //String compStr = "host 192.168.43.190";       
        
        // Compile the filter
        int retFilterCompiler = pcap.compile(bpf, compStr, optim, netm);
        
        int retSetFilter = pcap.setFilter(bpf);
        if (retSetFilter==-1) {
            // double check to see that compiler also gave an error
            if (retFilterCompiler==Pcap.OK){
                System.out.println("Strange... Compiler error missing!");
            }
            System.out.println("SetFilter FAILED");
            System.err.println(pcap.getErr());
            
            // We dont want to continue. Return
            return;
        }
        else {
            // All good
            System.out.println("\nSetFilter SUCCEED -> " + compStr + "\n");
        }
        
        
        String ofile = "C:\\Users\\nri\\Documents\\mypcap.pcap";
        PcapDumper dumper = pcap.dumpOpen(ofile); // output file  

        
        /*************************************************************************** 
         * Third we create a packet handler which will receive packets from the 
         * libpcap loop. 
         **************************************************************************/
        JBufferHandler<PcapDumper> dumpHandler  = new JBufferHandler<PcapDumper>() {
            
            @Override
            public void nextPacket(PcapHeader header, JBuffer buffer, PcapDumper dumper) {
                
                dumper.dump(header, buffer); // This will cause error the second loop. But right now.. we're not even capturing any RadioTap info, so we're not even passing the first loop.
                dumper.close();
                
                System.out.println("Dumphandler");
                try {
                    
                    decode_me(ofile);
                    
                }
                catch (Exception me){
                    System.out.println(me);
                   
                }
                
            }
        };
        
        PcapPacketHandler<String> jpacketHandler = new PcapPacketHandler<String>() {  
            
            @Override
            public void nextPacket(PcapPacket packet, String user) {  
                    
                System.out.printf("Received packet at %s caplen=%-4d len=%-4d %s\n",  
                    new Date(packet.getCaptureHeader().timestampInMillis()),   
                    packet.getCaptureHeader().caplen(),  // Length actually captured  
                    packet.getCaptureHeader().wirelen(), // Original length   
                    user                                 // User supplied object  
                    );
                
                // Lets extract som IP addresses and protocols.
                Tcp tcp = new Tcp();
                Ip4 ip = new Ip4();
                byte[] sIP = new byte[4];
                byte[] dIP = new byte[4];
                String sourceIP;
                String destIP;
                if(packet.hasHeader(ip)&&packet.hasHeader(tcp)){
                    sIP = packet.getHeader(ip).source();
                    sourceIP = org.jnetpcap.packet.format.FormatUtils.ip(sIP);
                    dIP = packet.getHeader(ip).destination();
                    destIP = org.jnetpcap.packet.format.FormatUtils.ip(dIP);
                    System.out.println("*"+sourceIP+"*"+destIP);
                    System.out.println("Source IP"+ sourceIP);
                    System.out.println("Destination IP"+ destIP);
                    PcapHeader head = packet.getCaptureHeader();
                    
                    
                    if (tcp.source()==80){
                        System.out.println("\n\nHTTP protocol 80\n\n");
                    }
                    else if (tcp.source()==23) {                    
                        System.out.println("\n\nTelnet protocol 23\n\n");                        
                    }
                    else if (tcp.source()==443) {
                        System.out.println("\n\nHTTPS protocol 443\n\n");
                    }
                    else {
                        System.out.println("\n\n Protocol ? \n" + tcp.source());                        
                    }
                    

                } 
                else {
                    System.out.println("No header Found: ");
                }
               
               
                // System.out.println("\n\nCapture header \n" + packet.getCaptureHeader().toDebugString()); 
                System.out.println("To String:\n" + packet.toString());
                //System.out.println(" ");
                //System.out.println("To HexDump:\n" + packet.toHexdump());
                
                
              
                
                
                
            }  
        };  
  
        /*************************************************************************** 
         * Fourth we enter the loop and tell it to capture 10 packets. The loop 
         * method does a mapping of pcap.datalink() DLT value to JProtocol ID, which 
         * is needed by JScanner. The scanner scans the packet buffer and decodes 
         * the headers. The mapping is done automatically, although a variation on 
         * the loop method exists that allows the programmer to sepecify exactly 
         * which protocol ID to use as the data link type for this pcap interface. 
         **************************************************************************/  
        
        // I used 0 before.. but loop_infinite seems to be working good. I'll keep it for now.
        // pcap.loop(0, jpacketHandler, "Nima rocks!");  
        //pcap.loop(Pcap.LOOP_INFINITE, jpacketHandler, "Nima rocks!");  
        pcap.loop(20, dumpHandler, dumper);  
        dumper.close();
        
        
        
        /*************************************************************************** 
         * Last thing to do is close the pcap handle 
         **************************************************************************/  
        pcap.close();  
        
        
    } 

    
    
    
    public static void decode_me(String myfile) {
        
                
        System.out.println("here1");

        long startTime = System.currentTimeMillis();
      
        byte[] dataFromFile = new byte[]{};
        

        dataFromFile = readFile(myfile);

        System.out.println("here2");               


        if (dataFromFile.length > 0) {
            
            System.out.println("here30");
            PcapDecoderMe pcapNgDecoder = new PcapDecoderMe(dataFromFile);
            byte status = pcapNgDecoder.decode();
            System.out.println(status); 
            
            RadioTap radioTap;
                   
            if (status == DecoderStatus.SUCCESS_STATUS)
            {
                
                
                System.out.println("here31");

                
                System.out.println("here33");        
                ArrayList radioTapList = new ArrayList();                
                
                System.out.println("here333");
                
                for (int i = 0; i  < pcapNgDecoder.getSectionList().size();i++) {
                    
                    System.out.println("here4");
                    
                    if (pcapNgDecoder.getSectionList() instanceof IEnhancedPacketBLock)
                    {
                        System.out.println("here5");

                        IEnhancedPacketBLock packet = (IEnhancedPacketBLock) pcapNgDecoder.getSectionList();

                        try {
                                // decode radiotap frame for this packet data
                                radioTap = new RadioTap(packet.getPacketData());
                                radioTapList.add(radioTap);
                                
                                //radiotapFrame.get(i).add(radioTap);
                        } catch (RadioTapException e) {
                                e.printStackTrace();
                                return;
                        }
                        
                    }
                }

                long endTime   = System.currentTimeMillis();
                long totalTime = endTime - startTime;

                System.out.println("decoding time : " + totalTime + " ms");
               
                //DisplayPacket.decode(radiotapFrame);
                sub_decode(radioTapList);
                
            }
        }
    }
    
    public static void sub_decode(ArrayList<IRadioTapFrame> radiotapFrame) {
        
        for (int i = 0; i<radiotapFrame.size(); i++) {
            
        
        System.out.println("RadioTap Version : " + radiotapFrame.get(i).getRadiotapVersion());
        System.out.println("RadioTap length  : " + radiotapFrame.get(i).getRadioTapDataLength());
        System.out.println("RadioTap data    : ");

        if (radiotapFrame.get(i).getRadioTapFlagList().isTFST())
                System.out.println("\tTFST                 : " + radiotapFrame.get(i).getRadioTapData().getTFST() + "ms");
        if (radiotapFrame.get(i).getRadioTapFlagList().isFlags())
                System.out.println("\tflags                : " + radiotapFrame.get(i).getRadioTapData().getFlags());
        if (radiotapFrame.get(i).getRadioTapFlagList().isDataRate())
                System.out.println("\tdata rate            : " + radiotapFrame.get(i).getRadioTapData().getDataRate()+"kbps");
        if (radiotapFrame.get(i).getRadioTapFlagList().isDbmAntSignal())
                System.out.println("\tant signal in dbm    : " + radiotapFrame.get(i).getRadioTapData().getDbmAntSignal()+" dbm");
        if (radiotapFrame.get(i).getRadioTapFlagList().isDbmAntNoise())
                System.out.println("\tant noise in dbm     : " + radiotapFrame.get(i).getRadioTapData().getDbmAntNoise()+" dbm");
        if (radiotapFrame.get(i).getRadioTapFlagList().isLockQuality())
                System.out.println("\tlock quality         : " + radiotapFrame.get(i).getRadioTapData().getLockQuality()+" (unitless)");
        if (radiotapFrame.get(i).getRadioTapFlagList().isDbTxAttenuation())
                System.out.println("\ttx Attenuation       : " + radiotapFrame.get(i).getRadioTapData().getDbTxAttenuation()+" db");
        if (radiotapFrame.get(i).getRadioTapFlagList().isTxAttenuation())
                System.out.println("\ttx Attenuation       : " + radiotapFrame.get(i).getRadioTapData().getTxAttenuation()+" (unitless) (max power emitted)");
        if (radiotapFrame.get(i).getRadioTapFlagList().isDbmTxPower())
                System.out.println("\ttx power in dbm      : " + radiotapFrame.get(i).getRadioTapData().getDbmTxPower()+" dbm (absolute power level measured at the antenna port)");
        if (radiotapFrame.get(i).getRadioTapFlagList().isAntenna())
                System.out.println("\tantenna              : " + radiotapFrame.get(i).getRadioTapData().getAntenna()+" (unitless) (indication of the Rx/Tx antenna for this packet. The first antenna is antenna 0)");
        if (radiotapFrame.get(i).getRadioTapFlagList().isDbAntennaSignal())
                System.out.println("\tantenna signal in db : " + radiotapFrame.get(i).getRadioTapData().getDbAntennaSignal()+" db (RF signal power at the antenna, decibel difference from an arbitrary, fixed reference)");
        if (radiotapFrame.get(i).getRadioTapFlagList().isDbAntennaNoise())
                System.out.println("\tantenna noise in db  : " + radiotapFrame.get(i).getRadioTapData().getDbAntennaNoise()+" db (RF noise power at the antenna, decibel difference from an arbitrary, fixed reference)");
        if (radiotapFrame.get(i).getRadioTapFlagList().isRxFlags())
                System.out.println("\tPLCP CRC error       : " + radiotapFrame.get(i).getRadioTapData().isPlcpCrcErrors());

        if (radiotapFrame.get(i).getRadioTapFlagList().isChannel())
        {
            System.out.println("\t\tchannel number         : " + radiotapFrame.get(i).getRadioTapData().getChannel().getChannelNum());
            System.out.println("\t\tfrequency used         : " + radiotapFrame.get(i).getRadioTapData().getChannel().getFrequency()+"MHz");
            System.out.println("\t\tCCK channel            : " + radiotapFrame.get(i).getRadioTapData().getChannel().isCckChannel());
            System.out.println("\t\tDYNAMIC CCK channel    : " + radiotapFrame.get(i).getRadioTapData().getChannel().isDynamicCckOfdmChannel());
            System.out.println("\t\tGFSK channel           : " + radiotapFrame.get(i).getRadioTapData().getChannel().isGfskChannel());
            System.out.println("\t\tOFDM channel           : " + radiotapFrame.get(i).getRadioTapData().getChannel().isOfdmChannel());
            System.out.println("\t\tonly passive scan      : " + radiotapFrame.get(i).getRadioTapData().getChannel().isOnlyPassiveScanAllowed());
            System.out.println("\t\tspectrum channel 2GHZ  : " + radiotapFrame.get(i).getRadioTapData().getChannel().isSpectrumChannel2GHZ());
            System.out.println("\t\tspectrum channel 5GHZ  : " + radiotapFrame.get(i).getRadioTapData().getChannel().isSpectrumChannel5GHZ());
            System.out.println("\t\tturbo channel          : " + radiotapFrame.get(i).getRadioTapData().getChannel().isTurboChannel());
        }

        if (radiotapFrame.get(i).getRadioTapFlagList().isFHSS())
        {
                System.out.print("FHSS NOT DECODED !!!!");
        }
        if (radiotapFrame.get(i).getRadioTapFlagList().isVht())
        {
                System.out.print("VHT NOT DECODED !!!!");
        }
        if (radiotapFrame.get(i).getRadioTapFlagList().isMcs())
        {
                System.out.print("MCS NOT DECODED !!!!");
        }
        if (radiotapFrame.get(i).getRadioTapFlagList().isAmpdu())
        {
                System.out.print("AMPDU NOT DECODED !!!!");
        }
        System.out.println("###############################################################################################");
        
        }
    }
    
    public static byte[] readFile(String path) {
		Path path2 = Paths.get(path);

		byte[] data = new byte[] {};

		try {
			data = Files.readAllBytes(path2);
		} catch (IOException e) {
			System.err.print("Error file path is incorrect");
		}
		return data;
	}
}  
