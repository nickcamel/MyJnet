/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package myjnet;







/**
 *
 * @author nri
 */
import java.util.ArrayList;
import org.jnetpcap.Pcap;  
import org.jnetpcap.PcapIf;  
import org.jnetpcap.packet.PcapPacket;  
import org.jnetpcap.packet.PcapPacketHandler;  
import org.jnetpcap.nio.JBuffer;


import java.util.Arrays;
import java.util.List;



  
/** 
 * Here is the output generated by this example : 
 *  
 *  Network devices found: 
 *  #0: \Device\NPF_{BC81C4FC-242F-4F1C-9DAD-EA9523CC992D} [Intel(R) PRO/100 VE]  
 *  #1: \Device\NPF_{E048DA7F-D007-4EEF-909D-4238F6344971} [VMware Virtual Ethernet Adapter] 
 *  #2: \Device\NPF_{5B62B373-3EC1-460D-8C71-54AA0BF761C7} [VMware Virtual Ethernet Adapter] 
 *  #3: \Device\NPF_GenericDialupAdapter [Adapter for generic dialup and VPN capture] 
 *  
 *  Choosing 'Intel(R) PRO/100 VE) ' on your behalf: 
 *  Received packet at Tue Nov 03 18:52:42 EST 2009 caplen=1362 len=1362 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=82   len=82   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=145  len=145  jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=62   len=62   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=164  len=164  jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=62   len=62   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=54   len=54   jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=1073 len=1073 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=1514 len=1514 jNetPcap rocks! 
 *  Received packet at Tue Nov 03 18:52:45 EST 2009 caplen=279  len=279  jNetPcap rocks! 
 */  
public class MyRadioTapFileIter {  
  
    static long[] i_timestamp = new long[2];
    /** 
     * Main startup method 
     *  
     * @param args 
     *          ignored 
     */  
    public static void main(String[] args) {  
        List<PcapIf> alldevs = new ArrayList<PcapIf>(); // Will be filled with NICs  
        StringBuilder errbuf = new StringBuilder(); // For any error msgs  
  
        /*************************************************************************** 
         * First get a list of devices on this system 
         **************************************************************************/  
       
        //String fname = "C:\\users\\nri\\Downloads\\mesh.pcap";
        String fname = "C:\\users\\nri\\Downloads\\beacon.pcap";
        //String fname = "/media/sf_Downloads/beacon.pcap";
        
        System.out.println("Peep");
        Pcap pcap = Pcap.openOffline(fname, errbuf);
        
        
        
        
        int[] T = new int[2];
        int i_T = 0;
                   
        PcapPacketHandler<String> jpacketHandler = new PcapPacketHandler<String>() {  
            
            @Override
            public void nextPacket(PcapPacket packet, String user) {  
               
               
               readPacket(packet);
                
                
            }  
        };  
        
        // I used 0 before.. but loop_infinite seems to be working good. I'll keep it for now.
        // pcap.loop(0, jpacketHandler, "Nima rocks!");  
        //pcap.loop(Pcap.LOOP_INFINITE, jpacketHandler, "Nima rocks!");  
       pcap.loop(20, jpacketHandler, "Nima rocks!");  
       
        
        
        
        /*************************************************************************** 
         * Last thing to do is close the pcap handle 
         **************************************************************************/  
        pcap.close();
        
        
    } 
    
    
    
    public static void readPacket(PcapPacket packet) {
        
        // Init
        int packet_size = packet.size();
        JBuffer packet_buf = packet;   
        
         // throw away first 40 bytes (magic number etc etc...)
        // System.out.println("Throwing away Frame header!");
        // .getByteArray will itself skip frame header (40 bytes)
        // packet does NOT contain file header!
        byte[] data = packet_buf.getByteArray(0, packet_size);
        
        
        int max_byte_read = Math.min(packet_size, 160);
    
                       
        System.out.println("Available bytes in packet: " + packet_size);
        System.out.println("Number of bytes to process: " + max_byte_read);

        /**
         * Kepping this section just for printing (dev)
         */
        if (false) {
            int i = 0;
            for (byte b : data) {

                if (i%16==0){

                    System.out.printf("%s: ", Integer.toHexString(i|0x100).substring(1));
                }

                if (b>=0) {
                    System.out.printf("%s ", Integer.toHexString(b|0x100).substring(1));
                    //System.out.printf("Byte : %s  Hex : %s\n", b, Integer.toHexString(b));
                }
                else {
                    System.out.printf("%s ", Integer.toHexString(256+b));
                    //System.out.printf("Byte : %s  Hex : %s\n", b, Integer.toHexString(256+b));
                }

                i++;
                if (i%16==0){
                    System.out.println("");
                }

                if (i>=max_byte_read){
                    System.out.println("");
                    break;
                }
            }
        }
         /**
        * 
        */
        int[] data_int = new int[max_byte_read];
        for (int k = 0; k<max_byte_read; k++) {
           data_int[k] = data[k]&0xFF;
        }

        byte[] frame_control = new byte[2];
        byte[] duration = new byte[2];
        byte[] dest_ip = new byte[6];
        byte[] src_ip = new byte[6];
        byte[] bss_id = new byte[6];
        byte[] seq_ctrl = new byte[2];
        
        byte[] time_stamp_bytes = new byte[8];
        byte[] time_stamp_bytes_tmp = new byte[8];        
        long time_stamp = 0;
        long tmp;
        long tmp2;
                
        byte[] beacon_interval = new byte[2];
        byte[] capability_info = new byte[2];
        byte[] tag_nr = new byte[1];
        byte[] tag_len = new byte[1];

        if (data_int[0]==0x80) {
            // It's a beacon
            System.out.printf("It's a beacon!\n");
            frame_control = Arrays.copyOfRange(data, 0, 2);
            duration = Arrays.copyOfRange(data, 2, 4);
            dest_ip = Arrays.copyOfRange(data, 4, 10);
            src_ip = Arrays.copyOfRange(data, 10, 16);
            bss_id = Arrays.copyOfRange(data, 16, 22);
            seq_ctrl = Arrays.copyOfRange(data, 22, 24);
            
            
            time_stamp_bytes_tmp = Arrays.copyOfRange(data, 24, 32);
            for (int k = 0; k<8; k++) {
                time_stamp_bytes[k] = time_stamp_bytes_tmp[7-k];                
            }
            
            for (int k = 0; k<8; k++){
                tmp = (time_stamp_bytes[k]&0xFF);
                tmp2 = tmp<<((7-k)*8);
                time_stamp += tmp2;                
            }
            
            
            beacon_interval = Arrays.copyOfRange(data, 32, 34);
            capability_info = Arrays.copyOfRange(data, 34, 36);
            tag_nr = Arrays.copyOfRange(data, 36, 37);
            tag_len = Arrays.copyOfRange(data, 37, 38);

            int ss_id_len = tag_len[0];

            byte[] ss_id = new byte[ss_id_len];

            ss_id = Arrays.copyOfRange(data, 38, 38+ss_id_len);

            System.out.printf("SSID: ");
            for (byte b : ss_id) {
                int c = b&0xFF;
                System.out.printf("%s", (char) c);    
            }
            
            
           // System.out.println("Time Stamp: " + time_stamp);
            
                        
            System.out.printf("\n\n");
            
            if (i_timestamp[0]==0) {
                i_timestamp[0] = time_stamp;
            } 
            else {
                i_timestamp[1] = time_stamp;
                
                System.out.printf("Time diff: %s\n\n", (i_timestamp[1]-i_timestamp[0]));
                
                i_timestamp[0] = 0;
                i_timestamp[1] = 0;
            }
            
        }
        else {
            System.out.println("Not a beacon unfortunately\n\n");
        }
        
       
          
       
 
        
       
        
        
            
        
    }
}  
